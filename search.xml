<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>念念手纪</title>
      <link href="//%E5%BF%B5%E5%BF%B5%E6%89%8B%E7%BA%AA/"/>
      <url>//%E5%BF%B5%E5%BF%B5%E6%89%8B%E7%BA%AA/</url>
      
        <content type="html"><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a>念念手纪</h4><a id="more"></a><p>最近，看了两部岩井俊二的两部电影《你好,之华》《情书》和一部我到目前为止最喜欢的一部日本电影了，它既是关于爱情的电影，也不是关于爱情的电影，不对，不能这样说，应该是一部关于爱的电影，嗯，这个还是比较贴合主题的至少对我来说是很贴切的。主角正式上场了，它就是《念念手纪》，说实话，在这几部电影之前，我还对日本电影具有很大的隔阂，也可能是历史原因吧。但是自从看了这几部电影之后，让我对日本电影有了一个新的认识，至少在某些方面日本还是很强的这是不可否认的时期。</p><p>好了，废话不说，开始谈谈这几部电影吧。首先来说《念念手纪》，它是根据日本一部叫《请吃掉我的胰脏》的漫画改编的，虽然没有看过原著漫画，但是从电影来看画这部漫画的人，应该是一个很强的人，而且有着很强的生活经历。至少在我看完后，整整一天我都在想着这件事，想着可爱的樱良，想着没有樱良后的志贺春树，想着失去好友的恭子。在整部电影中最让我感到的是，樱良的勇敢，虽然有很多人觉得女主怎么不好，丑啦，怎么的，但是我却不这样认为，也许有些人的要求比较高吧。樱良是善良的，在全班没有一个人注意到志贺春树的时候，只有她注意到了。她把每个人都当做是自己的同学。樱良与春树第一次的说话是在医院里，而命运就是这么巧，正好樱良的共读病例被春树捡到了，致使春树知道了这么一个秘密，一个只属于樱良自己的秘密，甚至这个笔记连她自己的家人都没有看过。</p><p>之后，樱良开始去当图书管理员，因为这时的春树是一个喜好读书的人，只有书和他相伴在这之前。但是这时的樱良表现得很坦然自若，像一个没事人一样，当时我还在想，这女孩也太强大了吧，强大的让我感觉的都有点假了。后台才知道原来她也是会害怕的，虽然在别人面前很强大，但是内心却是很害怕，这正不是大多数人的表现吗？为了自己的在乎的人会在他们面前表现得很强大，但是当只有自己的时候就会显得那么的弱小。</p><p>樱良总会在看见春树的时候显得精神，因为她羡慕春树，羡慕春树的强大，春树总是一个人，不管遇到什么困难都是他一个人在面对，在解决。而樱良自始至终都觉得自己是靠他人，如果没有其他的人，她根本面对不了那么多的困难。而春树在很樱良相处一段时间之后也开始羡慕樱良，羡慕樱良有那么多的朋友，在班里面多么受欢迎。他们两个都是想成为对方的人。樱良对春树说过如果吃掉一个人的胰脏，那么那个人就会一直的活在另一个人的身体里面。从中可以看出樱良是多么的想活下去，但是，她也清楚自己的病情，知道是不可能的。所以说出这样的话，既是无奈之举，也是求生的欲望。</p><p>在樱良住院的时候，春树第一次去看他的时，樱良故意让春树和恭子见面，让他们成为朋友，因为樱良觉得自己去世后，春树就没有可以说话的朋友了，当然这是从侧面我自己推断出来的，但是在剧中确是说恭子看人不怎么样，希望春树可以照顾恭子。樱良说自己想要去看一次樱花，春树想要完成这她的愿望，约定好在樱良出院的时候去旅行。</p><p>当樱良可以出院的时候，俩人约好了去见面，春树在他们之前去过的蛋糕店里，而樱良先去了图书馆，写下了两份遗书，藏到了小王子那本书中。春树在这个时候用手机给樱良发消息，他写了很多字，一一列举出樱良的可爱之处，写出来自己想说的话，但是最后，他全部删了之后，写出来一句，我想吃掉你的胰脏。但是到最后，春树也没有等到樱良的到来。在春树回家的路上，知道了樱良的死讯，原来樱良被一个随机杀人犯残忍的杀害了。这也就成了整部电影最让我感觉到心情不好的地方，我以为的结局是春树在完成樱良的最后一个愿望的时候完成后安逸的走了，但是导演却给我们来了这么一出，确实出乎我的意料，也许就是因为这样的结局，才会有电影这么艺术的存在了吧。</p><p>樱良猜的很对，春树很胆小，不会出席自己的葬礼的，其实樱良也知道，只是春树不能接受樱良不在了的事实。在春树缓过来的时候，去祭拜了樱良，也从樱良母亲手里拿过了共病文库，看着樱良写的文库，春树终于在最后哭了出来。</p><p>多年过后，春树当了老师，因为樱良的一句话，我觉得你很适合当老师。在老师的岗位上，他甚至觉得没有任何意思，写好了辞职书准备辞职。但是在接到让他去整理即将要拆除的图书馆的时候，春树心里一怔。也许他当时是不愿意走进那个拥有好多记忆的图书馆。但是最后春树还是进去了，在哪里春树在一个偶然间貌似听到了樱良的声音，追了过去。这时候就回到了电影开头的地方。就在恭子结婚的那天，春树偶然发现了用借书卡写的线索，突然想到了之前樱良说过的话，找到了那本小王子，翻开书后找到了两份遗书，一个给恭子，一个给他。</p><p>春树二话没说拿着信，就去找恭子了，恭子看过信后嚎啕大哭，而春树终于把那就想和你做朋友的话对恭子说出口了。春树在回到办公室后，撕掉自己的辞职信，开始和同事们说话聊天，和同事们融洽相处。</p><p>电影的最后，春树和自己的学生在正在拆除的图书馆门前，学生同样被一个女孩一直在逗着玩，当看到学生很不能理解的时候，春树说，她只想和你交朋友。<br>整部电影看完后，给我的不是波浪不断，而是心情极其的平复，平复的让我不停的去想，整整一天都在想，偶尔也会想到樱良乐观可爱的模样。我发现自己并不能很好的释怀，虽然是一部电影，但却给我的感觉却是不安。抱着让我可以释怀的心情，我写下了这篇文章，希望对自己有用，可以让自己从电影当中走出来，回到这个实实在在的世界中去。<br>                                                                                        (2018.12.11晚)</p>]]></content>
      
      
      <categories>
          
          <category> Movies </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Japan </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vuex</title>
      <link href="//Vuex/"/>
      <url>//Vuex/</url>
      
        <content type="html"><![CDATA[<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><a id="more"></a><h4 id="what-is-vuex"><a href="#what-is-vuex" class="headerlink" title="what is vuex?"></a>what is vuex?</h4><p>首先我们可以看看官网介绍的<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex</a>，对于大多数新手来说，官方文档写的很不好理解。<br>vuex顾名思义，就是为vue.js应用开发的，它是一种<strong>状态管理模式</strong>，用来管理我们的数据，当然我们也可以不用vuex来管理我们的数据，但是大型的vue应用就不可缺了<br>它的首要目标就是方便我们数据的管理和组件之间数据的传递，官方文档里所说的<strong>状态</strong>一词，我们也可以简单的理解为是数据，方法，当然这样理解还是有一点差强人意，但是起码对我这个菜鸟来说是可以更好的理解这个状态到底是什么东西？<br>我们来设想一下两个场景：</p><ul><li>多个视图依赖与同一种状态</li><li>来自不同视图的行为需要变更同一种状态<br>对于第一个场景来说我们可以采用prop传参的方法，如果是多层嵌套的组件的话，就会显得非常繁琐，麻烦，并且如果是兄弟组件的话，就会更加复杂<br>对于第二个场景来说我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝<br>但是以上两种方式很大的问题就是代码无法维护</li></ul><p>在这个极度困难的时期，vuex就横空出世，它把组件中共享的状态抽取出来，自己组成一个全局实例，让任何组件都可以获取状态或者触发行为，vuex也遵循了一定的规则，使我们的代码更加结构化且容易维护</p><h4 id="vuex-核心"><a href="#vuex-核心" class="headerlink" title="vuex 核心"></a>vuex 核心</h4><ul><li>state   </li><li>getters   </li><li>mutations</li><li>actions</li></ul><p><strong>使用方法</strong>:在main.js里面引入store.js,并且在vue实例中挂载store<br>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到</p><pre><code>let store = new Vuex.store({    state(){        //状态    },    getters(){        // 获取状态    },    mutations(){        // 提交状态    },    actions(){        // 提交mutations    }})</code></pre><h5 id="state"><a href="#state" class="headerlink" title="state"></a>state</h5><p>首先翻译过来就有状态的意思，顾名思义，就是储存状态的地方，它是一个第一的状态树，用一个对象包含了全部的应用层级状态，所以它是一个唯一的数据源，这也意味着每个对象仅仅包含一个store实例。<br>v<br>获得vuex的状态可以使用:</p><pre><code>this.$store.state.count// count 是state里的属性</code></pre><p>Vuex的状态储存是响应式的，所以从store实例中读取状态的最好方法是在computed(计算属性)中使用<br><strong>注</strong>：由于Vuex是响应式的，因此每次页面刷新的时候vuex里的状态都会初始化，最好使用localStroage解决</p><h5 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h5><p>它是为了在state中输出的时候可以更好的实现一些自定义的状态，就像是Vue中的fillter一样，它的最大优势就是可以缓存，从而提升性能，就像是vue中的计算属性一样，只有当它的依赖改变的时候才会重新计算。</p><p>它可以接受多个参数，第一个参数必须是state<br>getter暴露的是一个store.getters对象，所以我们可以以属性的方式去访问</p><pre><code>this.$store.getters.func //func是在getters当中定义的方法</code></pre><p><strong>注意</strong>:getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><p>提交mutations是更改状态的唯一方法，每个mutation都有一个字符串的事件类型和回调函数，这个回调函数就是我们实际进行状态更改的地方，同样它的第一个参数也是state</p><p>首先我们来看一下mutation的事件类型，它是一个字符串，当在页面中需要更改状态的时候，在页面中我们不可以像调用方法那样去提交，而是通过store.commit(‘String’)的方式去提交。这里的String是mutation中的事件名，那么问题来了，为什么要这样提交？其实这更像是一个事件注册，它的类型是字符串，当然我们也可以使用常量，例如：</p><pre><code>const types = {    FUN1:&#39;fun1&#39;,    FUN2:&#39;fun2&#39;}mutations:{    [types.FUN1]:(state) =&gt; {    },    [types.FUN2]:(state) =&gt; {    }}</code></pre><p>当然我们也可以不这么些，这样写的目的是使代码更加清晰，更加容易维护，当然如果我们直接使用mutation去更改状态的话，还是建议不这么写，因为在页面中的话，会使得代码很不好理解，也会显得比较突兀</p><p><strong>Payload</strong>，称为载荷，简单来说就是传递的值或者对象，一般来说传递对象会更好<br>Mutation 需遵守 Vue 的响应规则：</p><ul><li>最好提前在store中初始化所有的属性</li><li>如果你是在使需要在使用过程中添加新属性的时候，可以使用vue.set()</li></ul><p>最重要的一点是，mutation必须是同步函数，因为我们要跟踪和观察commit所提交的，如果是异步的话，就很难观察commit所提交的</p><p>那么如果我们必须用异步来提交怎么办昵？<br>所以vuex就给出了actions</p><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><p>actions跟mutation倒是有几分相似，它们的不同点在于</p><ul><li>actions提交的是mutation，不是直接改变状态，状态的改变还是得靠mutation</li><li>actions是可以进行异步操作的，所以一般来说，我们还是用actions提交</li></ul><p>Actions有一个context对象，我们可以调用context.commit提交mutation，或者我们也可以通过context.state和context.getters获取状态和方法。那么问题来了，这个context是什么东西哪，如果它可以获取到state和getters，那么它会不会就是store本身哪？答案是肯定不是它自己了，我们可以这么看，Vuex还有一个对象那就是modules，这个models是为了解决state在大型应用的时候会变的很复杂而产生的，module将store分成不同的模块，每个模块都拥有自己的state,getters,mutations,actions。这样的话，我们就可以知道context到底是谁了，它可以看成是不同的模块的实例，而不是store，具体可以看<a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">Models</a></p><p>现在来看一个actions实例</p><pre><code>actions:{    increment({ commit }){ // 这里的{ commit }是ES6中的代码解构        commit(&#39;increment&#39;)    }}</code></pre><p>页面或者组件中使用actions: 使用分发Action</p><pre><code>store.dispatch(&#39;increment&#39;)</code></pre><p>action 也同样支持载荷方式和对象方式进行分发</p><pre><code>//payloadstore.dispatch(&#39;increment&#39;,acount);//objstore.dispatch({ type:&#39;increment&#39;,acount:10 });</code></pre><p>以上是Vuex的基础知识，后续还是需要继续跟进和学习</p><p>2018-12-2(完)</p>]]></content>
      
      
      <categories>
          
          <category> vuex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>token验证</title>
      <link href="//token%E9%AA%8C%E8%AF%81/"/>
      <url>//token%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h3 id="node-token验证"><a href="#node-token验证" class="headerlink" title="node token验证"></a>node token验证</h3><a id="more"></a><p><a href="https://blog.csdn.net/djjj123456789/article/details/81980587" target="_blank" rel="noopener">详细步骤</a></p><h4 id="为了开发方便，在node中我们使用passport、passport-jwt、jsonwebtoken-这个三个模块生成token，并且验证"><a href="#为了开发方便，在node中我们使用passport、passport-jwt、jsonwebtoken-这个三个模块生成token，并且验证" class="headerlink" title="为了开发方便，在node中我们使用passport、passport-jwt、jsonwebtoken 这个三个模块生成token，并且验证"></a>为了开发方便，在node中我们使用passport、passport-jwt、jsonwebtoken 这个三个模块生成token，并且验证</h4><p>通过使用passport</p><pre><code>passport.authenticate(&#39;jwt&#39;,{session:false})</code></pre><p>当代码执行到上面代码的时候，它会自动寻找config下的passport，并执行在passport中的代码进而验证token是否合法</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>axios</title>
      <link href="//axios/"/>
      <url>//axios/</url>
      
        <content type="html"><![CDATA[<h4 id="Vue-vue-cli-3-0-项目中-axios-的请求拦截和响应拦截"><a href="#Vue-vue-cli-3-0-项目中-axios-的请求拦截和响应拦截" class="headerlink" title="Vue(vue-cli 3.0) 项目中 axios 的请求拦截和响应拦截"></a>Vue(vue-cli 3.0) 项目中 axios 的请求拦截和响应拦截</h4><a id="more"></a><h2 id="Vue-vue-cli-3-0-项目中-axios-的请求拦截和响应拦截-1"><a href="#Vue-vue-cli-3-0-项目中-axios-的请求拦截和响应拦截-1" class="headerlink" title="Vue(vue-cli 3.0) 项目中 axios 的请求拦截和响应拦截"></a>Vue(vue-cli 3.0) 项目中 axios 的请求拦截和响应拦截</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>vue中使用axios，axios方法自带了interceptors(拦截器),请求和响应都可以通过这个拦截器来实现拦截，通过配置interceptors来实现<br>简单点来说就是监听请求和监听响应，当请求发出或者响应的时候我们可以准确的知道</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>src目录下新建http.js文件，并导入axios，</li><li>完成拦截器的配置后在main.js中导入http.js </li><li>在main.js中通过Vue.prototype.$axios = axios 来实现在全局中使用$axios</li></ol><h3 id="http-js"><a href="#http-js" class="headerlink" title="http.js"></a>http.js</h3><pre><code>// 请求拦截axios.interceptors.request.use(config =&gt; {        // 拦截成功         return config;    },err =&gt; {        //失败        return Promise.reject(err)});//响应拦截axios.interceptors.response.use(response =&gt; {    //拦截成功    return response},err =&gt; {    //失败    return Promise.reject(err);})</code></pre><h4 id="注-使用http-js是为了统一处理http的请求和响应，实现了代码的模块化，也好后期维护"><a href="#注-使用http-js是为了统一处理http的请求和响应，实现了代码的模块化，也好后期维护" class="headerlink" title="注:使用http.js是为了统一处理http的请求和响应，实现了代码的模块化，也好后期维护"></a>注:使用http.js是为了统一处理http的请求和响应，实现了代码的模块化，也好后期维护</h4><hr>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue.js 笔记</title>
      <link href="//Vue-js-%E7%AC%94%E8%AE%B0/"/>
      <url>//Vue-js-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="Vue-学习笔记"><a href="#Vue-学习笔记" class="headerlink" title="Vue 学习笔记"></a>Vue 学习笔记</h4><a id="more"></a><h2 id="vue-js"><a href="#vue-js" class="headerlink" title="vue.js"></a>vue.js</h2><h4 id="框架和库"><a href="#框架和库" class="headerlink" title="框架和库"></a>框架和库</h4><ul><li>框架(vue angular react) 拥有完整的解决方案,被动(人家调用)<ul><li>vue全家桶 vue.js + vue-router + vuex(管理组件) + axios(获取数据)</li><li>vue渐进式框架 通过组合,最终成为一个完整的框架</li></ul></li><li>库(jquery zepto animate.css)  主动(自动调用)</li></ul><h3 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC,MVVM"></a>MVC,MVVM</h3><ul><li>MVC(单项)<ul><li>model 数据</li><li>view 视图</li><li>controller 控制器</li></ul></li><li>MVVM(双向)<ul><li>model 数据</li><li>view 视图</li><li>viewModel 视图模型</li></ul></li></ul><h3 id="vue-js-1"><a href="#vue-js-1" class="headerlink" title="vue.js"></a>vue.js</h3><pre><code>- directive(指令):只是DOM上的行间属性，本身是没有意义的，但是vue给这类属性赋予一定的意义来实现一些特殊的功能,所以指令都以v- 开头</code></pre><h4 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h4><hr><h5 id="父组件主动访问子组件的方法和属性"><a href="#父组件主动访问子组件的方法和属性" class="headerlink" title="父组件主动访问子组件的方法和属性"></a>父组件主动访问子组件的方法和属性</h5><pre><code>通过给子组件标签设置属性 ref=&quot;reference&quot; 在父组件中访问子组件的属性和方法     this.$refs.reference.property(属性)    this.$refs.reference.func(方法)</code></pre><h5 id="子组件主动访问父组件的方法和属性"><a href="#子组件主动访问父组件的方法和属性" class="headerlink" title="子组件主动访问父组件的方法和属性"></a>子组件主动访问父组件的方法和属性</h5><pre><code>vue 直接提供了子组件访问父组件的方法 this.$parent直接在子组件中用 this.$parent.property/func</code></pre><h5 id="非父子组件的传值-兄弟组件"><a href="#非父子组件的传值-兄弟组件" class="headerlink" title="非父子组件的传值(兄弟组件)"></a>非父子组件的传值(兄弟组件)</h5><pre><code>可以使用一个空的Vue实例作为中央事件总线：        //新建一个bus.js文件        var bus = new Vue();        export default bus;        //触发组件A中的事件        bus.$emit(&#39;id-selected&#39;,1);        //在组件B中创建的构子中监听事件(mounted)        bus.$on(&#39;id-selected&#39;,(id)=&gt;{            // ...        })</code></pre><hr><h4 id="vue路由-当访问不同页面的时候，显示不同的组件"><a href="#vue路由-当访问不同页面的时候，显示不同的组件" class="headerlink" title="vue路由(当访问不同页面的时候，显示不同的组件)"></a>vue路由(当访问不同页面的时候，显示不同的组件)</h4><ul><li>首先安装VueRouter 之后在main.js中引入VueRouter(vue内部提供的模块要用Vue.use(VueRouter))<br>1.创建组件，引入组件<br>2.定义路由<pre><code>const routes = {  {path:&#39;/foo&#39;,component:Foo},  {path:&#39;/bar&#39;,component:Bar}}</code></pre>3.实例化VueRouter<pre><code>const router = new VueRouter({  routes})</code></pre>4.挂载<pre><code>new Vue({  el:&#39;#app&#39;,  router})</code></pre><ul><li>路由配置完毕后，在模板(vue组件)中<br><code>`</code><!-- 使用router-link组件来导航 --><!-- 使用to属性指定链接，并且to属性中的链接要与路由配置的链接地址一样 --><!-- router-link会默认渲染成一个a标签 --><router-link to="/foo"></router-link><br><router-link to="/bar"></router-link><!-- 路由出口 --><!-- 匹配路由会渲染到这里 --><router-view></router-view></li></ul></li></ul><pre><code>- 动态路由和get传值    - 我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件，因此就使用[动态路由](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96)实现    - 可以在 vue-router 的路由路径中使用&quot;动态路径参数&quot;(dynamic segment) 来达到这个效果    - 通过动态路由传过来的值，可在对应的子组件中使用this.$route.parmas.name 获取值    - get传值 to=/foo?id=1 在对于的子组件中可以使用this.$route.parmas.name 获取值###### 通过动态路由，组件获取到后端api中的id，之后在组件中发起请求，渲染内容-------#### vue 编程式导航(实际上是使用JavaScript实现页面的跳转)</code></pre><p>eg：在登陆界面的时候，点击登陆后，如果用router-link，就没有办法渲染，因此，<a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">编程式导航</a>可以解决这类问题</p><pre><code>// 字符串router.push(&#39;home&#39;)// 对象router.push({ path: &#39;home&#39; })// 命名的路由router.push({ name: &#39;user&#39;, params: { userId: 123 }})// 带查询参数，变成 /register?plan=privaterouter.push({ path: &#39;register&#39;, query: { plan: &#39;private&#39; }})</code></pre><pre><code>- [HTML5 History模式](https://router.vuejs.org/zh/guide/essentials/history-mode.html)------#### Vuex 是一个专为 Vue.js 设计的状态管理模式##### vuex解决了组件之间同一状态的共享问题。当我们的应用遇到多个组件共享状态时，会需要：多个组件依赖于同一状态。传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。这需要你去学习下，vue编码中多个组件之间的通讯的做法。来自不同组件的行为需要变更同一状态。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。来自官网的一句话：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态。这里的关键在于集中式存储管理。这意味着本来需要共享状态的更新是需要组件之间通讯的，而现在有了vuex，就组件就都和store通讯了。问题就自然解决了。这就是为什么官网再次会提到Vuex构建大型应用的价值。如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。2018-10-12#### [computed,methods,watch](https://cn.vuejs.org/v2/guide/computed.html)- methods 里面是方法，调用完毕后就会被垃圾回收机制清除  computed 叫做计算属性，最大的特点是存在缓存机制，当符合要求时不会改变，缺点是不支持异步  watch 叫做监听，于computed相比是支持异步的，#### v-if/v-show- v-if 操作的是DOM- v-show 操作的是样式v-bind 动态绑定属性#### 单页面开发的方式- 通过hash记录跳转的路径(可以产生历史管理))- 浏览器自带的历史记录管理方法history (history.pushState()) 又可能会导致404错误一般开发是时候使用hash 但上线的时候会使用history#### 实现全局域名的配置  - 新建domain 文件夹，domain.js 文件</code></pre><pre><code>        const domain = &#39;http://192.168.1.107:3000&#39;;   export default {   ```    url:domain} ```</code></pre><ul><li><p>在子组件中导入</p></li><li><p>axios </p><ul><li>axios.defaults.baseURL = ‘<a href="http://192.168.1.1&#39;" target="_blank" rel="noopener">http://192.168.1.1&#39;</a>  默认url 请求路径</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>THE FIRST BLOG ABOUT MYSELF</title>
      <link href="//first-blog/"/>
      <url>//first-blog/</url>
      
        <content type="html"><![CDATA[<h4 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h4><a id="more"></a><p>今天是我在github上搭建好自己的blog后的第一篇自己的blog，也许对于我来说这是一个很好的开端，可以让我把自己的所思所想去写下来，同样在技术方面我也可以记录自己的学习经历，可以借用blogs去提升自我。</p><p>第一篇blog我不知道该写一些什么东西昵？感觉有好多想写的，但是又不知道该从何写起。选择总是那么困难，像一个一个已经系成死扣的扣子，不知道如何下手。思来想去，还是随便写写吧，毕竟只是是自己的随笔，并不需要那么正式：</p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><p>从了解到搭建成功这一个blog，我用了不少时间，其中花费时间主要的原因就是我对于博客系统的不熟悉所导致的，在通过查找了资料和借鉴曾经搭建过博客的小伙伴的经验，自己也增长了不少经验，所以说经验真的是自己去体验所得的，看书，听课是永远都找不到的</p><h3 id="理解能力"><a href="#理解能力" class="headerlink" title="理解能力"></a>理解能力</h3><p>虽然说最后还是可以看来，但是通过看技术博客和文章中可以很好的发现自己的短板–理解能力，话说我自始至终都没有完整的看过一本书，虽然有看过但都是中途放弃的，从而导致我现在的理解能力是出奇的差啊，所以理解能力还是我主要提升的点之一</p><h3 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h3><p>说到该如何学习，我想自己还是没有发言权，毕竟自己不是个学霸(算是一个好一点的学渣)，但似乎除了这在就没有写的了，很奇怪，还是说一下吧，我觉得最好的资料还是文档，就是哪些英文原文文档，如果有很好的英语基础的话，还是得看英文原文的文档，尽量不要看中文文档，一来可以学习英文锻炼自己的理解能力和阅读能力，二来嘛，就是可以成为有B格的programer，如果遇到自己不能理解的也可以百度，google等，最好的是还能浏览一下StackOverflow等，所以说，还是要善于运用这些现有的工具来更好的帮助我们学习新的知识。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><h5 id="第一篇，总有一些地方不尽人意，也是能力的问题，还需要自己去不断写，不断提高自己写作的能力。万事开头难，努力做到自己想做到的样子，称为一个自己想成为的人。"><a href="#第一篇，总有一些地方不尽人意，也是能力的问题，还需要自己去不断写，不断提高自己写作的能力。万事开头难，努力做到自己想做到的样子，称为一个自己想成为的人。" class="headerlink" title="第一篇，总有一些地方不尽人意，也是能力的问题，还需要自己去不断写，不断提高自己写作的能力。万事开头难，努力做到自己想做到的样子，称为一个自己想成为的人。"></a>第一篇，总有一些地方不尽人意，也是能力的问题，还需要自己去不断写，不断提高自己写作的能力。万事开头难，努力做到自己想做到的样子，称为一个自己想成为的人。</h5>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lives </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
