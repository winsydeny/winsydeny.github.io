<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Sydeny xi">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Vue.js 笔记">
  <meta property="og:description" content="the man who want to live like a really people">
  <meta property="og:site_name" content="The man&#39;s blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="The man&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>The man's blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Vue.js 笔记</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/winsydeny">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:1395854149@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Sydeny xi</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-11-20</span>
            <span class="time">20:54:39</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Vue/">Vue</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/note/">#note</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h4 id="Vue-学习笔记"><a href="#Vue-学习笔记" class="headerlink" title="Vue 学习笔记"></a>Vue 学习笔记</h4><a id="more"></a>
<h2 id="vue-js"><a href="#vue-js" class="headerlink" title="vue.js"></a>vue.js</h2><h4 id="框架和库"><a href="#框架和库" class="headerlink" title="框架和库"></a>框架和库</h4><ul>
<li>框架(vue angular react) 拥有完整的解决方案,被动(人家调用)<ul>
<li>vue全家桶 vue.js + vue-router + vuex(管理组件) + axios(获取数据)</li>
<li>vue渐进式框架 通过组合,最终成为一个完整的框架</li>
</ul>
</li>
<li>库(jquery zepto animate.css)  主动(自动调用)</li>
</ul>
<h3 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC,MVVM"></a>MVC,MVVM</h3><ul>
<li>MVC(单项)<ul>
<li>model 数据</li>
<li>view 视图</li>
<li>controller 控制器</li>
</ul>
</li>
<li>MVVM(双向)<ul>
<li>model 数据</li>
<li>view 视图</li>
<li>viewModel 视图模型</li>
</ul>
</li>
</ul>
<h3 id="vue-js-1"><a href="#vue-js-1" class="headerlink" title="vue.js"></a>vue.js</h3><pre><code>- directive(指令):只是DOM上的行间属性，本身是没有意义的，但是vue给这类属性赋予一定的意义来实现一些特殊的功能,所以指令都以v- 开头
</code></pre><h4 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h4><hr>
<h5 id="父组件主动访问子组件的方法和属性"><a href="#父组件主动访问子组件的方法和属性" class="headerlink" title="父组件主动访问子组件的方法和属性"></a>父组件主动访问子组件的方法和属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过给子组件标签设置属性 ref=&quot;reference&quot; </span><br><span class="line">在父组件中访问子组件的属性和方法 </span><br><span class="line">    this.$refs.reference.property(属性)</span><br><span class="line">    this.$refs.reference.func(方法)</span><br></pre></td></tr></table></figure>
<h5 id="子组件主动访问父组件的方法和属性"><a href="#子组件主动访问父组件的方法和属性" class="headerlink" title="子组件主动访问父组件的方法和属性"></a>子组件主动访问父组件的方法和属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue 直接提供了子组件访问父组件的方法 this.$parent</span><br><span class="line">直接在子组件中用 this.$parent.property/func</span><br></pre></td></tr></table></figure>
<h5 id="非父子组件的传值-兄弟组件"><a href="#非父子组件的传值-兄弟组件" class="headerlink" title="非父子组件的传值(兄弟组件)"></a>非父子组件的传值(兄弟组件)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可以使用一个空的Vue实例作为中央事件总线：</span><br><span class="line">    	//新建一个bus.js文件</span><br><span class="line">    	var bus = new Vue();</span><br><span class="line">        export default bus;</span><br><span class="line">        //触发组件A中的事件</span><br><span class="line">        bus.$emit(&apos;id-selected&apos;,1);</span><br><span class="line"></span><br><span class="line">        //在组件B中创建的构子中监听事件(mounted)</span><br><span class="line">        bus.$on(&apos;id-selected&apos;,(id)=&gt;&#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="vue路由-当访问不同页面的时候，显示不同的组件"><a href="#vue路由-当访问不同页面的时候，显示不同的组件" class="headerlink" title="vue路由(当访问不同页面的时候，显示不同的组件)"></a>vue路由(当访问不同页面的时候，显示不同的组件)</h4><ul>
<li>首先安装VueRouter 之后在main.js中引入VueRouter(vue内部提供的模块要用Vue.use(VueRouter))<br>1.创建组件，引入组件<br>2.定义路由<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const routes = &#123;</span><br><span class="line">    &#123;path:&apos;/foo&apos;,component:Foo&#125;,</span><br><span class="line">    &#123;path:&apos;/bar&apos;,component:Bar&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3.实例化VueRouter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>4.挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;,</span><br><span class="line">    router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>路由配置完毕后，在模板(vue组件)中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   &lt;!-- 使用router-link组件来导航 --&gt;</span><br><span class="line">   &lt;!-- 使用to属性指定链接，并且to属性中的链接要与路由配置的链接地址一样 --&gt;</span><br><span class="line">   &lt;!-- router-link会默认渲染成一个a标签 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/foo&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/bar&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">   &lt;!-- 路由出口 --&gt;</span><br><span class="line">   &lt;!-- 匹配路由会渲染到这里 --&gt;</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>动态路由和get传值<ul>
<li>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件，因此就使用<a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96" target="_blank" rel="noopener">动态路由</a>实现</li>
<li>可以在 vue-router 的路由路径中使用”动态路径参数”(dynamic segment) 来达到这个效果</li>
<li>通过动态路由传过来的值，可在对应的子组件中使用this.$route.parmas.name 获取值</li>
<li>get传值 to=/foo?id=1 在对于的子组件中可以使用this.$route.parmas.name 获取值<h6 id="通过动态路由，组件获取到后端api中的id，之后在组件中发起请求，渲染内容"><a href="#通过动态路由，组件获取到后端api中的id，之后在组件中发起请求，渲染内容" class="headerlink" title="通过动态路由，组件获取到后端api中的id，之后在组件中发起请求，渲染内容"></a>通过动态路由，组件获取到后端api中的id，之后在组件中发起请求，渲染内容</h6></li>
</ul>
</li>
</ul>
<hr>
<h4 id="vue-编程式导航-实际上是使用JavaScript实现页面的跳转"><a href="#vue-编程式导航-实际上是使用JavaScript实现页面的跳转" class="headerlink" title="vue 编程式导航(实际上是使用JavaScript实现页面的跳转)"></a>vue 编程式导航(实际上是使用JavaScript实现页面的跳转)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">eg：在登陆界面的时候，点击登陆后，如果用router-link，就没有办法渲染，因此，[编程式导航](https://router.vuejs.org/zh/guide/essentials/navigation.html)可以解决这类问题</span><br><span class="line"></span><br><span class="line">    // 字符串</span><br><span class="line">    router.push(&apos;home&apos;)</span><br><span class="line"></span><br><span class="line">    // 对象</span><br><span class="line">    router.push(&#123; path: &apos;home&apos; &#125;)</span><br><span class="line"></span><br><span class="line">    // 命名的路由</span><br><span class="line">    router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">    // 带查询参数，变成 /register?plan=private</span><br><span class="line">    router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">HTML5 History模式</a></li>
</ul>
<hr>
<h4 id="Vuex-是一个专为-Vue-js-设计的状态管理模式"><a href="#Vuex-是一个专为-Vue-js-设计的状态管理模式" class="headerlink" title="Vuex 是一个专为 Vue.js 设计的状态管理模式"></a>Vuex 是一个专为 Vue.js 设计的状态管理模式</h4><h5 id="vuex解决了组件之间同一状态的共享问题。当我们的应用遇到多个组件共享状态时，会需要："><a href="#vuex解决了组件之间同一状态的共享问题。当我们的应用遇到多个组件共享状态时，会需要：" class="headerlink" title="vuex解决了组件之间同一状态的共享问题。当我们的应用遇到多个组件共享状态时，会需要："></a>vuex解决了组件之间同一状态的共享问题。当我们的应用遇到多个组件共享状态时，会需要：</h5><p>多个组件依赖于同一状态。传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。这需要你去学习下，vue编码中多个组件之间的通讯的做法。<br>来自不同组件的行为需要变更同一状态。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。</p>
<p>以上的这些模式非常脆弱，通常会导致无法维护的代码。来自官网的一句话：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p>
<p>它采用集中式存储管理应用的所有组件的状态。这里的关键在于集中式存储管理。这意味着本来需要共享状态的更新是需要组件之间通讯的，而现在有了vuex，就组件就都和store通讯了。问题就自然解决了。</p>
<p>这就是为什么官网再次会提到Vuex构建大型应用的价值。如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。</p>
<p>2018-10-12</p>
<h4 id="computed-methods-watch"><a href="#computed-methods-watch" class="headerlink" title="computed,methods,watch"></a><a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener">computed,methods,watch</a></h4><ul>
<li>methods 里面是方法，调用完毕后就会被垃圾回收机制清除<br>computed 叫做计算属性，最大的特点是存在缓存机制，当符合要求时不会改变，缺点是不支持异步<br>watch 叫做监听，于computed相比是支持异步的，</li>
</ul>
<h4 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if/v-show"></a>v-if/v-show</h4><pre><code>- v-if 操作的是DOM
- v-show 操作的是样式

v-bind 动态绑定属性
</code></pre><h4 id="单页面开发的方式"><a href="#单页面开发的方式" class="headerlink" title="单页面开发的方式"></a>单页面开发的方式</h4><pre><code>- 通过hash记录跳转的路径(可以产生历史管理))
- 浏览器自带的历史记录管理方法history (history.pushState()) 又可能会导致404错误

一般开发是时候使用hash 但上线的时候会使用history
</code></pre><h4 id="实现全局域名的配置"><a href="#实现全局域名的配置" class="headerlink" title="实现全局域名的配置"></a>实现全局域名的配置</h4><ul>
<li><p>新建domain 文件夹，domain.js 文件</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 	const domain = &apos;http://192.168.1.107:3000&apos;;</span><br><span class="line">export default &#123;</span><br></pre></td></tr></table></figure>
<pre><code>url:domain
</code></pre><p>}<br> <code>`</code></p>
</li>
<li><p>在子组件中导入</p>
</li>
<li><p>axios </p>
<ul>
<li>axios.defaults.baseURL = ‘<a href="http://192.168.1.1&#39;" target="_blank" rel="noopener">http://192.168.1.1&#39;</a>  默认url 请求路径</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

