<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘ç²’å­ç‰¹æ•ˆç³»ç»Ÿ        * {       margin: 0;       padding: 0;       box-sizing: border-box;     }      body {       font-family: &#39;Segoe UI&#39;, Tahoma, Geneva, Verdana, sans-serif;       back">
<meta property="og:type" content="website">
<meta property="og:title" content="Sydeny">
<meta property="og:url" content="http://example.com/gesture-christmas-tree.html">
<meta property="og:site_name" content="Sydeny">
<meta property="og:description" content="æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘ç²’å­ç‰¹æ•ˆç³»ç»Ÿ        * {       margin: 0;       padding: 0;       box-sizing: border-box;     }      body {       font-family: &#39;Segoe UI&#39;, Tahoma, Geneva, Verdana, sans-serif;       back">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-12T13:58:54.930Z">
<meta property="article:modified_time" content="2025-12-12T13:58:54.930Z">
<meta property="article:author" content="Sydeny">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon_my.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon_my.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_my.png">
          
        
    
    <!-- title -->
    <title>Sydeny</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
    
    
    <div class="content index width mx-auto px2 my4">
        
          <header id="header">
  <a href="/">
  
    
      <div id="logo" style="background-image: url(/images/my-logo.png);"></div>
    
  
    <div id="title">
      <h1>Sydeny</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#"><i class="fa fa-bars fa-2x"></i></a>
      </li>
       
        <li><a href="/">Home</a></li>
       
        <li><a href="/categories/">Category</a></li>
       
        <li><a href="/about/">About</a></li>
      
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  
  

  <div class="content" itemprop="articleBody">
    <!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘ç²’å­ç‰¹æ•ˆç³»ç»Ÿ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a1428 0%, #1a472a 50%, #2d1b3d 100%);
      overflow: hidden;
      height: 100vh;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .ui-container {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(10, 20, 40, 0.8);
      padding: 20px;
      border-radius: 12px;
      border: 2px solid rgba(255, 215, 0, 0.3);
      font-size: 14px;
      color: #d4af37;
      backdrop-filter: blur(10px);
      pointer-events: auto;
      max-width: 350px;
      font-family: 'Monaco', monospace;
    }

    .controls h3 {
      margin-bottom: 15px;
      color: #ffd700;
      font-size: 16px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .control-item {
      margin-bottom: 10px;
      line-height: 1.6;
    }

    .gesture-info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(10, 20, 40, 0.8);
      padding: 20px;
      border-radius: 12px;
      border: 2px solid rgba(220, 20, 60, 0.3);
      color: #ffd700;
      pointer-events: auto;
      backdrop-filter: blur(10px);
      font-family: 'Monaco', monospace;
      min-width: 200px;
    }

    .gesture-info h4 {
      color: #ff1744;
      margin-bottom: 10px;
      font-size: 14px;
      text-shadow: 0 0 10px rgba(255, 23, 68, 0.5);
    }

    .status {
      color: #4caf50;
      font-size: 13px;
      text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
    }

    .upload-section {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(10, 20, 40, 0.8);
      padding: 15px;
      border-radius: 12px;
      border: 2px solid rgba(255, 215, 0, 0.3);
      pointer-events: auto;
      backdrop-filter: blur(10px);
    }

    .upload-section label {
      color: #ffd700;
      display: block;
      margin-bottom: 8px;
      font-size: 13px;
      font-weight: bold;
    }

    .upload-section input[type="file"] {
      display: block;
      margin-bottom: 10px;
      font-size: 12px;
      color: #d4af37;
      cursor: pointer;
    }

    .upload-section button {
      background: linear-gradient(135deg, #2d5a2d 0%, #4a7c4e 100%);
      color: #ffd700;
      border: 2px solid rgba(255, 215, 0, 0.3);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s ease;
      font-weight: bold;
      text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }

    .upload-section button:hover {
      background: linear-gradient(135deg, #3d7a3d 0%, #5a9c5e 100%);
      border-color: rgba(255, 215, 0, 0.6);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #ffd700;
      display: none;
      z-index: 100;
    }

    .loading.active {
      display: block;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 215, 0, 0.3);
      border-top: 4px solid #ffd700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .state-indicator {
      position: absolute;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      background: rgba(10, 20, 40, 0.8);
      padding: 20px;
      border-radius: 12px;
      border: 2px solid rgba(220, 20, 60, 0.3);
      color: #ffd700;
      pointer-events: auto;
      backdrop-filter: blur(10px);
      text-align: center;
      font-family: 'Monaco', monospace;
      min-width: 150px;
    }

    .state-indicator h4 {
      color: #ff1744;
      margin-bottom: 10px;
      font-size: 14px;
    }

    .state-text {
      font-size: 16px;
      font-weight: bold;
      color: #4caf50;
      text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    }

    /* æç¤ºæ–‡å­— */
    .hint-text {
      position: absolute;
      bottom: 30%;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: rgba(255, 215, 0, 0.6);
      font-size: 14px;
      pointer-events: none;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 0.6;
      }

      50% {
        opacity: 1;
      }
    }

    /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
    @media (max-width: 768px) {
      .controls {
        top: 10px;
        left: 10px;
        padding: 12px;
        font-size: 12px;
        max-width: 280px;
      }

      .controls h3 {
        font-size: 14px;
        margin-bottom: 10px;
      }

      .control-item {
        font-size: 11px;
        margin-bottom: 8px;
      }

      .upload-section {
        top: 10px;
        right: 10px;
        padding: 12px;
      }

      .upload-section label {
        font-size: 12px;
        margin-bottom: 6px;
      }

      .gesture-info {
        bottom: 10px;
        left: 10px;
        padding: 12px;
        min-width: 180px;
        font-size: 12px;
      }

      .gesture-info h4 {
        font-size: 12px;
        margin-bottom: 8px;
      }

      .state-indicator {
        top: 50%;
        right: 10px;
        padding: 15px;
        min-width: 120px;
      }

      .state-indicator h4 {
        font-size: 12px;
      }

      .state-text {
        font-size: 14px;
      }

      .hint-text {
        font-size: 12px;
      }
    }

    @media (max-width: 480px) {
      .controls {
        max-width: 240px;
        font-size: 11px;
      }

      .control-item {
        font-size: 10px;
        margin-bottom: 6px;
      }

      .upload-section input[type="file"] {
        font-size: 10px;
      }

      .upload-section button {
        padding: 6px 12px;
        font-size: 10px;
      }

      .gesture-info {
        min-width: 160px;
        font-size: 10px;
        padding: 10px;
      }

      .state-indicator {
        padding: 12px;
        min-width: 100px;
      }

      .state-text {
        font-size: 13px;
      }
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <div class="ui-container">
    <!-- æ§åˆ¶è¯´æ˜ -->
    <div class="controls">
      <h3>ğŸ„ æ‰‹åŠ¿æ§åˆ¶</h3>
      <div class="control-item">
        <strong style="color: #ff6b6b;">âœŠ æ¡æ‹³ï¼š</strong>åˆæ‹¢åœ£è¯æ ‘
      </div>
      <div class="control-item">
        <strong style="color: #4caf50;">âœ‹ äº”æŒ‡ï¼š</strong>æ•£å¼€æ‰€æœ‰å…ƒç´ 
      </div>
      <div class="control-item">
        <strong style="color: #2196f3;">ğŸ”„ æ—‹è½¬æ‰‹ï¼š</strong>æ—‹è½¬è§†è§’
      </div>
      <div class="control-item">
        <strong style="color: #ff9800;">ğŸ¤Œ æŠ“æ¡ï¼š</strong>æ”¾å¤§ç…§ç‰‡
      </div>
      <div
        style="margin-top: 15px; border-top: 1px solid rgba(255, 215, 0, 0.2); padding-top: 15px; font-size: 12px; opacity: 0.8;">
        ç¡®ä¿ç›¸æœºæœ‰æƒé™è®¿é—®ï¼Œæ‰èƒ½è¿›è¡Œæ‰‹åŠ¿è¯†åˆ«ã€‚
      </div>
    </div>

    <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
    <div class="state-indicator">
      <h4>å½“å‰çŠ¶æ€</h4>
      <div class="state-text" id="stateDisplay">åˆå§‹åŒ–ä¸­...</div>
    </div>

    <!-- æ‰‹åŠ¿è¯†åˆ«ä¿¡æ¯ -->
    <div class="gesture-info">
      <h4>ğŸ“· æ‰‹åŠ¿è¯†åˆ«</h4>
      <div class="status" id="gestureStatus">ç­‰å¾…æ£€æµ‹...</div>
      <div style="margin-top: 10px; font-size: 11px; opacity: 0.7;">
        <div>æ‰‹æ£€æµ‹: <span id="handDetected">æ— </span></div>
        <div>å½“å‰æ‰‹åŠ¿: <span id="currentGesture">-</span></div>
      </div>
    </div>

    <!-- ç…§ç‰‡ä¸Šä¼  -->
    <div class="upload-section">
      <label>ğŸ“¸ ä¸Šä¼ ç…§ç‰‡</label>
      <input type="file" id="photoInput" accept="image/*" multiple>
      <button id="uploadBtn">ä¸Šä¼ ç…§ç‰‡</button>
      <div style="margin-top: 10px; font-size: 11px; color: rgba(255, 215, 0, 0.6);">
        å·²åŠ è½½: <span id="photoCount">0</span> å¼ 
      </div>
    </div>

    <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
    <div class="loading" id="loading">
      <div class="spinner"></div>
      <div>åˆå§‹åŒ–ä¸­...</div>
    </div>

    <!-- æç¤ºæ–‡å­— -->
    <div class="hint-text" id="hintText">
      å±•å¼€æ‰‹æŒæˆ–æ¡æ‹³æ¥æ§åˆ¶åœ£è¯æ ‘
    </div>
  </div>

  <!-- å¼•å…¥å¿…è¦çš„åº“ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/RenderPass.js"></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>

  <script>
    // ==================== ç§»åŠ¨ç«¯æ£€æµ‹ ====================
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // ==================== é…ç½®å’Œå¸¸é‡ ====================
    const CONFIG = {
      // é¢œè‰²é…ç½®
      colors: {
        mattGreen: 0x2d5a2d,
        metallicGold: 0xffd700,
        christmasRed: 0xdc143c,
        darkGreen: 0x1a3a1a,
        lightGold: 0xffed4e,
      },
      // ç²’å­é…ç½® - ç§»åŠ¨ç«¯å‡å°‘æ•°é‡
      particles: {
        count: isMobile ? 80 : 150,
        sphereRadius: 3,
        positionRange: 15,
      },
      // åŠ¨ç”»é…ç½®
      animation: {
        transitionDuration: 1000, // æ¯«ç§’
        rotationSpeed: 0.005,
      },
      // æ‰‹åŠ¿æ£€æµ‹é…ç½®
      gesture: {
        thumbUpThreshold: 0.5,
        fingerSpreadThreshold: 0.15,
      }
    };

    // ==================== å…¨å±€å˜é‡ ====================
    let scene, camera, renderer, composer, bloomPass;
    let particles = [];
    let photoMeshes = [];
    let treeElements = [];
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let currentState = 'idle'; // idle, collapsed, expanded, photoZoom
    let targetState = 'collapsed';
    let cameraController = {
      phi: 0,
      theta: Math.PI / 4,
      radius: 20,
      targetPhi: 0,
      targetTheta: Math.PI / 4,
    };
    let handLandmarks = null;
    let photos = [];
    let selectedPhotoIndex = -1;
    let isInitialized = false;
    let gestureState = {
      handDetected: false,
      currentGesture: 'none',
      fingerCount: 0,
    };

    // ==================== æ‰‹åŠ¿è¯†åˆ«è®¾ç½® ====================
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.5,
    });

    hands.onResults(onHandsResults);

    // åˆ›å»ºè§†é¢‘å…ƒç´ ç”¨äºè·å–æ‘„åƒå¤´è¾“å…¥
    let video;

    // ==================== åˆå§‹åŒ– ====================
    async function init() {
      // è®¾ç½®Three.jsåœºæ™¯
      setupScene();
      setupLighting();
      setupComposer();

      // åˆ›å»ºåˆå§‹æ ‘å½¢çŠ¶
      createChristmasTree();

      // å¯åŠ¨æ‰‹åŠ¿è¯†åˆ«
      try {
        await initializeMediaPipe();
      } catch (error) {
        console.error('æ— æ³•åˆå§‹åŒ–æ‘„åƒå¤´:', error);
        alert('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
        return;
      }

      isInitialized = true;
      document.getElementById('loading').classList.remove('active');
      updateStateDisplay('collapsed');

      // å¼€å§‹æ¸²æŸ“å¾ªç¯
      animate();
    }

    // åˆå§‹åŒ–MediaPipe
    async function initializeMediaPipe() {
      // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒ getUserMedia
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.error('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®');
        alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ã€‚\n\nè¯·ç¡®ä¿ï¼š\n1. ä½¿ç”¨ HTTPS è¿æ¥ï¼ˆæˆ– localhostï¼‰\n2. æµè§ˆå™¨ä¸ºæœ€æ–°ç‰ˆæœ¬ï¼ˆChromeã€Firefoxã€Safariã€Edgeï¼‰\n3. å·²æˆäºˆæ‘„åƒå¤´æƒé™');
        throw new Error('æµè§ˆå™¨ä¸æ”¯æŒ getUserMedia');
      }

      // åˆ›å»ºéšè—çš„è§†é¢‘å…ƒç´ 
      video = document.createElement('video');
      video.style.display = 'none';
      video.setAttribute('playsinline', 'true'); // iOS å¿…éœ€
      document.body.appendChild(video);

      try {
        // è·å–æ‘„åƒå¤´æµ - ç§»åŠ¨ç«¯ä½¿ç”¨ facingMode: 'user'
        const constraints = {
          video: isMobile
            ? {
              facingMode: 'user',
              width: { ideal: 640 },
              height: { ideal: 480 }
            }
            : {
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
        };

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        video.play();

        // å½“è§†é¢‘å‡†å¤‡å¥½æ—¶ï¼Œå¼€å§‹å¤„ç†
        video.onloadedmetadata = () => {
          processVideo();
        };
      } catch (error) {
        console.error('æ‘„åƒå¤´é”™è¯¯:', error);
        if (error.name === 'NotAllowedError') {
          alert('éœ€è¦æ‘„åƒå¤´æƒé™æ‰èƒ½ä½¿ç”¨æ­¤åº”ç”¨ã€‚è¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸è®¿é—®æ‘„åƒå¤´ã€‚');
        } else if (error.name === 'NotFoundError') {
          alert('æœªæ‰¾åˆ°æ‘„åƒå¤´è®¾å¤‡ã€‚è¯·ç¡®ä¿æ‚¨çš„è®¾å¤‡æœ‰æ‘„åƒå¤´ã€‚');
        } else if (error.name === 'NotReadableError') {
          alert('æ— æ³•è®¿é—®æ‘„åƒå¤´ã€‚è¯·æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–åº”ç”¨æ­£åœ¨ä½¿ç”¨æ‘„åƒå¤´ã€‚');
        } else {
          alert('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥: ' + error.message + '\n\nè¯·ç¡®ä¿ä½¿ç”¨ HTTPS æˆ– localhost è®¿é—®æ­¤åº”ç”¨ã€‚');
        }
        throw error;
      }
    }

    // å¤„ç†è§†é¢‘æµ
    function processVideo() {
      const canvasElement = document.createElement('canvas');
      canvasElement.width = video.videoWidth;
      canvasElement.height = video.videoHeight;
      const canvasCtx = canvasElement.getContext('2d');

      async function send() {
        if (!video.paused && !video.ended) {
          // ç¿»è½¬è§†é¢‘ä»¥é€‚åº”self-cameraè§†è§’
          canvasCtx.save();
          canvasCtx.translate(canvasElement.width, 0);
          canvasCtx.scale(-1, 1);
          canvasCtx.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
          canvasCtx.restore();

          await hands.send({ image: canvasElement });
        }
        requestAnimationFrame(send);
      }
      send();
    }

    function setupScene() {
      const canvas = document.getElementById('canvas');

      // åˆ›å»ºåœºæ™¯
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a1428);
      scene.fog = new THREE.Fog(0x0a1428, 100, 200);

      // åˆ›å»ºç›¸æœº
      camera = new THREE.PerspectiveCamera(
        75,
        canvas.clientWidth / canvas.clientHeight,
        0.1,
        1000
      );
      camera.position.set(0, 5, 20);
      camera.lookAt(0, 0, 0);

      // åˆ›å»ºæ¸²æŸ“å™¨ - ç§»åŠ¨ç«¯é™ä½åƒç´ æ¯”
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = isMobile ? THREE.BasicShadowMap : THREE.PCFShadowShadowMap;
      renderer.outputEncoding = THREE.sRGBEncoding;

      // å¤„ç†çª—å£å¤§å°å˜åŒ–
      window.addEventListener('resize', onWindowResize);

      // ç§»åŠ¨ç«¯é˜²æ­¢ç¼©æ”¾
      document.addEventListener('touchmove', (e) => {
        if (e.scale !== 1) {
          e.preventDefault();
        }
      }, { passive: false });
    }

    function setupLighting() {
      // ç¯å¢ƒå…‰
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      // ä¸»å…‰æºï¼ˆé‡‘è‰²ï¼‰
      const mainLight = new THREE.DirectionalLight(0xffd700, 1.2);
      mainLight.position.set(10, 15, 10);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 2048;
      mainLight.shadow.mapSize.height = 2048;
      scene.add(mainLight);

      // è¾…åŠ©å…‰æºï¼ˆçº¢è‰²ï¼‰
      const redLight = new THREE.DirectionalLight(0xdc143c, 0.6);
      redLight.position.set(-10, 10, -15);
      scene.add(redLight);

      // ç‚¹å…‰æºï¼ˆç»¿è‰²ï¼‰
      const greenLight = new THREE.PointLight(0x2d5a2d, 0.8);
      greenLight.position.set(5, 8, 5);
      scene.add(greenLight);

      // æ·»åŠ è¿”å°„å…‰
      const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
      backLight.position.set(0, -5, -20);
      scene.add(backLight);
    }

    function setupComposer() {
      const canvas = document.getElementById('canvas');

      // æ£€æŸ¥EffectComposeræ˜¯å¦å¯ç”¨
      if (typeof THREE.EffectComposer !== 'undefined') {
        try {
          composer = new THREE.EffectComposer(renderer);
          const renderPass = new THREE.RenderPass(scene, camera);
          composer.addPass(renderPass);

          // è¾‰å…‰æ•ˆæœ
          if (typeof THREE.UnrealBloomPass !== 'undefined') {
            bloomPass = new THREE.UnrealBloomPass(
              new THREE.Vector2(canvas.clientWidth, canvas.clientHeight),
              1.5,
              0.4,
              0.85
            );
            composer.addPass(bloomPass);
          }
        } catch (error) {
          console.warn('EffectComposer åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æ ‡å‡†æ¸²æŸ“å™¨:', error);
          composer = null;
        }
      } else {
        console.warn('EffectComposer æœªå¯ç”¨ï¼Œä½¿ç”¨æ ‡å‡†æ¸²æŸ“å™¨');
        composer = null;
      }
    }

    // åˆ›å»ºåœ£è¯æ ‘å…ƒç´ 
    function createChristmasTree() {
      treeElements = [];

      // åˆ›å»ºæ ‘é”¥å½¢çš„çƒä½“å’Œç«‹æ–¹ä½“
      const treeColors = [CONFIG.colors.mattGreen, CONFIG.colors.christmasRed, CONFIG.colors.darkGreen];
      const decorColors = [CONFIG.colors.metallicGold, CONFIG.colors.lightGold, CONFIG.colors.christmasRed];

      // æ ‘çš„é”¥å½¢å±‚æ¬¡
      const layers = 4;
      for (let layer = 0; layer < layers; layer++) {
        const radius = 5 - layer * 1.2;
        const height = 15 - layer * 3;
        const count = 8 + layer * 2;

        // æ·»åŠ çƒä½“
        for (let i = 0; i < count; i++) {
          const angle = (i / count) * Math.PI * 2;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;
          const y = height + (Math.random() - 0.5) * 2;

          const sphereGeometry = new THREE.SphereGeometry(0.4, 16, 16);
          const color = treeColors[Math.floor(Math.random() * treeColors.length)];
          const sphereMaterial = new THREE.MeshStandardMaterial({
            color: color,
            metalness: 0.3,
            roughness: 0.6,
            emissive: color,
            emissiveIntensity: 0.2,
          });
          const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
          sphere.position.set(x, y, z);
          sphere.castShadow = true;
          sphere.receiveShadow = true;
          scene.add(sphere);

          treeElements.push({
            mesh: sphere,
            originalPosition: new THREE.Vector3(x, y, z),
            type: 'sphere',
          });
        }

        // æ·»åŠ ç³–æœæ£
        const candyCount = 6 + layer * 2;
        for (let i = 0; i < candyCount; i++) {
          const angle = (i / candyCount) * Math.PI * 2;
          const x = Math.cos(angle) * (radius + 1);
          const z = Math.sin(angle) * (radius + 1);
          const y = height;

          const candyGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1, 8);
          const candyColor = decorColors[Math.floor(Math.random() * decorColors.length)];
          const candyMaterial = new THREE.MeshStandardMaterial({
            color: candyColor,
            metalness: 0.8,
            roughness: 0.2,
            emissive: candyColor,
            emissiveIntensity: 0.3,
          });
          const candy = new THREE.Mesh(candyGeometry, candyMaterial);
          candy.position.set(x, y, z);
          candy.rotation.z = angle;
          candy.castShadow = true;
          candy.receiveShadow = true;
          scene.add(candy);

          treeElements.push({
            mesh: candy,
            originalPosition: new THREE.Vector3(x, y, z),
            type: 'candy',
          });
        }
      }

      // æ ‘å¹²
      const trunkGeometry = new THREE.CylinderGeometry(0.6, 1, 4, 16);
      const trunkMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        metalness: 0.1,
        roughness: 0.8,
      });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = -4;
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      scene.add(trunk);

      treeElements.push({
        mesh: trunk,
        originalPosition: new THREE.Vector3(0, -4, 0),
        type: 'trunk',
      });

      // æ˜Ÿé¡¶
      const starGeometry = new THREE.SphereGeometry(0.8, 32, 32);
      const starMaterial = new THREE.MeshStandardMaterial({
        color: CONFIG.colors.metallicGold,
        metalness: 0.9,
        roughness: 0.1,
        emissive: CONFIG.colors.metallicGold,
        emissiveIntensity: 0.5,
      });
      const star = new THREE.Mesh(starGeometry, starMaterial);
      star.position.y = 16;
      star.castShadow = true;
      star.receiveShadow = true;
      scene.add(star);

      treeElements.push({
        mesh: star,
        originalPosition: new THREE.Vector3(0, 16, 0),
        type: 'star',
      });

      // åˆ›å»ºç²’å­
      createParticles();
    }

    // åˆ›å»ºç²’å­ç³»ç»Ÿ
    function createParticles() {
      particles.forEach(p => scene.remove(p.mesh));
      particles = [];

      const geometry = new THREE.SphereGeometry(0.1, 8, 8);
      const particleColors = [
        CONFIG.colors.metallicGold,
        CONFIG.colors.christmasRed,
        CONFIG.colors.lightGold,
      ];

      for (let i = 0; i < CONFIG.particles.count; i++) {
        const color = particleColors[Math.floor(Math.random() * particleColors.length)];
        const material = new THREE.MeshStandardMaterial({
          color: color,
          metalness: 0.7,
          roughness: 0.3,
          emissive: color,
          emissiveIntensity: 0.3,
        });

        const mesh = new THREE.Mesh(geometry, material);

        // åˆå§‹ä½ç½®åœ¨æ ‘å‘¨å›´
        const angle = Math.random() * Math.PI * 2;
        const radius = 5 + Math.random() * 3;
        const y = (Math.random() - 0.5) * 20;

        mesh.position.set(
          Math.cos(angle) * radius,
          y,
          Math.sin(angle) * radius
        );

        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);

        particles.push({
          mesh: mesh,
          originalPosition: mesh.position.clone(),
          velocity: new THREE.Vector3(0, 0, 0),
          mass: 0.1,
        });
      }
    }

    // æ‰‹åŠ¿è¯†åˆ«å›è°ƒ
    function onHandsResults(results) {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handLandmarks = results.multiHandLandmarks[0];
        gestureState.handDetected = true;

        // è¯†åˆ«æ‰‹åŠ¿
        const gesture = recognizeGesture(handLandmarks);
        gestureState.currentGesture = gesture;
        gestureState.fingerCount = countFingers(handLandmarks);

        // æ ¹æ®æ‰‹åŠ¿æ”¹å˜æ ‘çš„çŠ¶æ€
        updateStateFromGesture(gesture);

        // è·å–æ‰‹çš„ä½ç½®ç”¨äºæ—‹è½¬
        if (gesture === 'rotate') {
          updateCameraRotation(handLandmarks);
        }

        // å¤„ç†ç…§ç‰‡æ”¾å¤§
        if (gesture === 'grab' && currentState === 'expanded') {
          selectPhotoFromGesture(handLandmarks);
        }
      } else {
        gestureState.handDetected = false;
        handLandmarks = null;
      }

      updateGestureDisplay();
    }

    // æ‰‹åŠ¿è¯†åˆ«å‡½æ•°
    function recognizeGesture(landmarks) {
      if (!landmarks || landmarks.length === 0) return 'none';

      const thumb = landmarks[4];
      const fingers = [landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
      const palm = landmarks[0];

      // è®¡ç®—æ‰‹éƒ¨æ–¹å‘
      const palmToMiddle = {
        x: landmarks[12].x - landmarks[0].x,
        y: landmarks[12].y - landmarks[0].y,
        z: landmarks[12].z - landmarks[0].z,
      };

      // è®¡ç®—æ‰‹æŒ‡å¼ å¼€ç¨‹åº¦
      let fingersUp = 0;

      // æ‹‡æŒ‡
      if (landmarks[4].x < landmarks[3].x) fingersUp++;

      // å…¶ä»–å››æŒ‡
      for (let i = 0; i < 4; i++) {
        if (fingers[i].y < landmarks[i * 4 + 2].y) fingersUp++;
      }

      // æ¡æ‹³ï¼šæ‰€æœ‰æ‰‹æŒ‡éƒ½å¼¯æ›²
      if (fingersUp <= 1) {
        return 'fist';
      }

      // äº”æŒ‡å¼ å¼€
      if (fingersUp >= 5) {
        return 'open';
      }

      // æŠ“æ¡åŠ¨ä½œ
      if (fingersUp === 2 || fingersUp === 3) {
        return 'grab';
      }

      // æ—‹è½¬æ‰‹ï¼ˆåŸºäºæ‰‹è…•ä½ç½®å˜åŒ–ï¼‰
      if (Math.abs(palmToMiddle.z) > 0.3) {
        return 'rotate';
      }

      return 'none';
    }

    // æ•°æ‰‹æŒ‡æ•°é‡
    function countFingers(landmarks) {
      let count = 0;

      // æ‹‡æŒ‡
      if (landmarks[4].x < landmarks[3].x) count++;

      // é£ŸæŒ‡åˆ°å°æŒ‡
      const tips = [8, 12, 16, 20];
      const pips = [6, 10, 14, 18];

      for (let i = 0; i < tips.length; i++) {
        if (landmarks[tips[i]].y < landmarks[pips[i]].y) {
          count++;
        }
      }

      return count;
    }

    // æ ¹æ®æ‰‹åŠ¿æ›´æ–°æ ‘çš„çŠ¶æ€
    function updateStateFromGesture(gesture) {
      if (gesture === 'fist' && currentState !== 'collapsed') {
        targetState = 'collapsed';
        startTransition();
      } else if (gesture === 'open' && currentState !== 'expanded') {
        targetState = 'expanded';
        startTransition();
      }
    }

    // æ›´æ–°ç›¸æœºæ—‹è½¬
    function updateCameraRotation(landmarks) {
      if (!landmarks || landmarks.length < 9) return;

      const wrist = landmarks[0];
      const middle = landmarks[9];

      // åŸºäºæ‰‹è…•å’Œä¸­æŒ‡çš„ä½ç½®è®¡ç®—æ—‹è½¬
      const deltaX = (middle.x - wrist.x) * 5;
      const deltaY = (middle.y - wrist.y) * 5;

      cameraController.targetPhi += deltaX * 0.05;
      cameraController.targetTheta += deltaY * 0.05;

      // é™åˆ¶è§’åº¦èŒƒå›´
      cameraController.targetTheta = Math.max(0.1, Math.min(Math.PI - 0.1, cameraController.targetTheta));
    }

    // ä»æ‰‹åŠ¿ä½ç½®é€‰æ‹©ç…§ç‰‡
    function selectPhotoFromGesture(landmarks) {
      if (!landmarks || photoMeshes.length === 0) return;

      const indexTip = landmarks[8];
      const thumbTip = landmarks[4];

      const distance = Math.sqrt(
        Math.pow(indexTip.x - thumbTip.x, 2) +
        Math.pow(indexTip.y - thumbTip.y, 2) +
        Math.pow(indexTip.z - thumbTip.z, 2)
      );

      // å½“é£ŸæŒ‡å’Œæ‹‡æŒ‡é è¿‘æ—¶ï¼Œé€‰æ‹©æœ€è¿‘çš„ç…§ç‰‡
      if (distance < 0.05) {
        const screenPos = {
          x: indexTip.x * 2 - 1,
          y: -(indexTip.y * 2 - 1),
        };

        raycaster.setFromCamera(screenPos, camera);
        const intersects = raycaster.intersectObjects(photoMeshes.map(p => p.mesh));

        if (intersects.length > 0) {
          const clickedMesh = intersects[0].object;
          const photoIndex = photoMeshes.findIndex(p => p.mesh === clickedMesh);

          if (photoIndex !== -1 && selectedPhotoIndex !== photoIndex) {
            selectedPhotoIndex = photoIndex;
            targetState = 'photoZoom';
            startTransition();
          }
        }
      }
    }

    // çŠ¶æ€è½¬æ¢
    function startTransition() {
      // è¿™ä¸ªå‡½æ•°å°†åœ¨åŠ¨ç”»å¾ªç¯ä¸­å¤„ç†å¹³æ»‘çš„è½¬æ¢
    }

    // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
    function updateStateDisplay(state) {
      const stateNames = {
        collapsed: 'åˆæ‹¢æ€ ğŸ„',
        expanded: 'æ•£å¼€æ€ âœ¨',
        photoZoom: 'ç…§ç‰‡æ”¾å¤§ ğŸ“¸',
        idle: 'åˆå§‹åŒ–ä¸­...',
      };

      document.getElementById('stateDisplay').textContent = stateNames[state] || 'æœªçŸ¥';
    }

    // æ›´æ–°æ‰‹åŠ¿æ˜¾ç¤º
    function updateGestureDisplay() {
      const handStatus = gestureState.handDetected ? 'âœ“ å·²æ£€æµ‹' : 'âœ— æœªæ£€æµ‹';
      const gestureMap = {
        fist: 'æ¡æ‹³',
        open: 'äº”æŒ‡å¼ å¼€',
        grab: 'æŠ“æ¡',
        rotate: 'æ—‹è½¬',
        none: '-',
      };

      document.getElementById('handDetected').textContent = handStatus;
      document.getElementById('currentGesture').textContent = gestureMap[gestureState.currentGesture] || '-';
      document.getElementById('gestureStatus').textContent = `æ£€æµ‹åˆ° ${gestureState.fingerCount} æ ¹æ‰‹æŒ‡`;
    }

    // å¤„ç†ç…§ç‰‡ä¸Šä¼ 
    document.getElementById('uploadBtn').addEventListener('click', async () => {
      const input = document.getElementById('photoInput');
      const files = input.files;

      if (files.length === 0) {
        alert('è¯·å…ˆé€‰æ‹©ç…§ç‰‡');
        return;
      }

      document.getElementById('loading').classList.add('active');

      for (const file of files) {
        await new Promise((resolve) => {
          const reader = new FileReader();

          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              addPhotoToScene(img);
              resolve();
            };
            img.src = e.target.result;
          };

          reader.readAsDataURL(file);
        });
      }

      document.getElementById('loading').classList.remove('active');
      document.getElementById('photoCount').textContent = photoMeshes.length;
      input.value = '';
    });

    // æ·»åŠ ç…§ç‰‡åˆ°åœºæ™¯
    function addPhotoToScene(image) {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');

      // ç»˜åˆ¶ç…§ç‰‡
      ctx.drawImage(image, 0, 0, 512, 512);

      // åˆ›å»ºæè´¨
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshStandardMaterial({
        map: texture,
        metalness: 0.2,
        roughness: 0.8,
        emissive: 0xffd700,
        emissiveIntensity: 0.1,
      });

      // åˆ›å»ºç½‘æ ¼
      const geometry = new THREE.PlaneGeometry(3, 3);
      const mesh = new THREE.Mesh(geometry, material);

      // éšæœºä½ç½®
      const angle = Math.random() * Math.PI * 2;
      const radius = 12;
      mesh.position.set(
        Math.cos(angle) * radius,
        (Math.random() - 0.5) * 15,
        Math.sin(angle) * radius
      );

      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);

      photoMeshes.push({
        mesh: mesh,
        texture: texture,
        originalPosition: mesh.position.clone(),
        originalScale: mesh.scale.clone(),
      });
    }

    // ä¸»åŠ¨ç”»å¾ªç¯
    function animate() {
      requestAnimationFrame(animate);

      // æ›´æ–°æ ‘çš„çŠ¶æ€å’ŒåŠ¨ç”»
      updateTreeState();

      // æ›´æ–°ç›¸æœºä½ç½®
      updateCamera();

      // æ—‹è½¬å…ƒç´ ä»¥å¢åŠ è§†è§‰æ•ˆæœ
      rotateElements();

      // æ›´æ–°ç²’å­
      updateParticles();

      // æ¸²æŸ“ - æ”¯æŒ EffectComposer å’Œæ ‡å‡†æ¸²æŸ“å™¨
      if (composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

    function updateTreeState() {
      if (currentState === targetState) return;

      const now = Date.now();
      if (!updateTreeState.startTime) {
        updateTreeState.startTime = now;
      }

      const elapsed = now - updateTreeState.startTime;
      const progress = Math.min(elapsed / CONFIG.animation.transitionDuration, 1);

      // åº”ç”¨EASINGå‡½æ•°
      const easeProgress = easeInOutCubic(progress);

      // æ›´æ–°æ ‘å…ƒç´ 
      treeElements.forEach((element) => {
        if (targetState === 'collapsed') {
          // æ”¶æ‹¢åˆ°åŸå§‹ä½ç½®
          element.mesh.position.lerp(element.originalPosition, easeProgress);
        } else if (targetState === 'expanded') {
          // æ•£å¼€åˆ°éšæœºä½ç½®
          if (!element.targetPosition) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 10;
            const y = (Math.random() - 0.5) * 20;
            element.targetPosition = new THREE.Vector3(
              Math.cos(angle) * distance,
              y,
              Math.sin(angle) * distance
            );
          }
          element.mesh.position.lerp(element.targetPosition, easeProgress);
        }
      });

      // æ›´æ–°ç…§ç‰‡
      photoMeshes.forEach((photo) => {
        if (targetState === 'photoZoom' && photoMeshes.indexOf(photo) === selectedPhotoIndex) {
          // æ”¾å¤§é€‰ä¸­çš„ç…§ç‰‡
          photo.mesh.position.lerp(new THREE.Vector3(0, 0, 5), easeProgress);
          const targetScale = new THREE.Vector3(4, 4, 1);
          photo.mesh.scale.lerp(targetScale, easeProgress);
          photo.mesh.rotation.z = Math.sin(elapsed * 0.001) * 0.02;
        } else if (targetState === 'photoZoom') {
          // å…¶ä»–ç…§ç‰‡æ·¡å‡º
          photo.mesh.material.opacity = 1 - easeProgress * 0.7;
        } else {
          // ç…§ç‰‡æ¢å¤å¯è§
          photo.mesh.material.opacity = 1;
        }
      });

      // å¦‚æœåŠ¨ç”»å®Œæˆ
      if (progress === 1) {
        currentState = targetState;
        updateTreeState.startTime = null;

        if (targetState === 'collapsed') {
          // æ¸…é™¤ç›®æ ‡ä½ç½®
          treeElements.forEach(e => delete e.targetPosition);
        }

        updateStateDisplay(currentState);
      }
    }

    function updateCamera() {
      // å¹³æ»‘çš„ç›¸æœºç§»åŠ¨
      cameraController.phi += (cameraController.targetPhi - cameraController.phi) * 0.1;
      cameraController.theta += (cameraController.targetTheta - cameraController.theta) * 0.1;

      const x = cameraController.radius * Math.sin(cameraController.theta) * Math.cos(cameraController.phi);
      const y = cameraController.radius * Math.cos(cameraController.theta);
      const z = cameraController.radius * Math.sin(cameraController.theta) * Math.sin(cameraController.phi);

      camera.position.set(x, y, z);
      camera.lookAt(0, 3, 0);
    }

    function rotateElements() {
      const time = Date.now() * 0.0003;

      treeElements.forEach((element) => {
        if (element.type === 'sphere' || element.type === 'star') {
          element.mesh.rotation.x += 0.005;
          element.mesh.rotation.y += 0.008;
        } else if (element.type === 'candy') {
          element.mesh.rotation.z += 0.01;
        }
      });

      photoMeshes.forEach((photo) => {
        if (selectedPhotoIndex !== photoMeshes.indexOf(photo)) {
          photo.mesh.rotation.y += 0.005;
          photo.mesh.position.y += Math.sin(time) * 0.01;
        }
      });
    }

    function updateParticles() {
      const time = Date.now() * 0.0005;

      particles.forEach((particle, index) => {
        if (currentState === 'expanded') {
          // ç²’å­åœ¨ç©ºé—´ä¸­æ¼‚æµ®
          const angle = time + (index / particles.length) * Math.PI * 2;
          const radius = 8 + Math.sin(time + index) * 2;

          particle.mesh.position.x = Math.cos(angle) * radius;
          particle.mesh.position.y = Math.sin(time + index) * 8;
          particle.mesh.position.z = Math.sin(angle) * radius;
        } else {
          // ç²’å­å›åˆ°åŸå§‹ä½ç½®
          particle.mesh.position.lerp(particle.originalPosition, 0.02);
        }

        particle.mesh.rotation.x += 0.01;
        particle.mesh.rotation.y += 0.015;
      });
    }

    // ç¼“åŠ¨å‡½æ•°
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // çª—å£å¤§å°å˜åŒ–å¤„ç†
    function onWindowResize() {
      const canvas = document.getElementById('canvas');
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.setSize(width, height);
      if (composer) {
        composer.setSize(width, height);
      }
    }

    // å¯åŠ¨åº”ç”¨
    // ç­‰å¾…æ‰€æœ‰è„šæœ¬åŠ è½½å®Œæˆ
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => init().catch(console.error), 100);
      });
    } else {
      setTimeout(() => init().catch(console.error), 100);
    }
  </script>
</body>

</html>
  </div>
</article>

    </div>
    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2025 Sydeny ,<br />
    Powered by the Hexo's theme of
    <a target="_blank" rel="noopener" href="https://github.com/sergodeeva/cactus-white"> cacuts-white </a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        
        <li><a href="/">Home</a></li>
        
        <li><a href="/categories/">Category</a></li>
        
        <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>



    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



